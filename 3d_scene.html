<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - 3D Scene</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
  </head>
  <style>
    #blocker {
	position: absolute;
	width: 100%;
	height: 100%;
	background-color: rgba(0,0,0,0.5);
    }
    #instructions {
	width: 100%; height: 100%;
	display: -webkit-box; display: -moz-box; display: box;
        
	-webkit-box-orient: horizontal;	-moz-box-orient: horizontal; box-orient: horizontal;
	-webkit-box-pack: center; -moz-box-pack: center; box-pack: center;
        
	-webkit-box-align: center; -moz-box-align: center; box-align: center;
        
	color: #ffffff;
	text-align: center;
	font-family: Arial;
	font-size: 20px;
	line-height: 30px;
	cursor: pointer;
    }
  </style>
  
  <body>
    <!-- See main.css for #info and #overlay for the markup attributes for it -->
    <div id="info">Welcome to our home, once again!</div>
    <!-- <div id="overlay">This is an overlay example.</div>  Uncomment if you want to see an overlay text --> 
    <div id="blocker">
      <div id="instructions">
        <span style="font-size:30px">Click to move around the room!</span>
        <br /><br />
        Show Controls: ESC<br/>
        Move: WASD<br/>
        Move Faster: LEFT SHIFT (HOLD)<br/>
        Look: MOUSE<br/>
        Reset Position: R<br/>
        Toggle Camera Flashlight On/Off: 0<br/>
        Toggle Red Light On/Off: 1<br/>
        Toggle Green Light On/Off: 2<br/>
        Toggle Blue Light On/Off: 3<br/>
        Toggle Desk Lamp On/Off: 4<br/>
        Toggle Copper Ball Rolling Animation On/Off: J<br/>
        Toggle Silver Ball Rolling Animation On/Off: K<br/>
        Toggle Dice Animation: L (Can't press again until animation ends)<br/><br/><br/>
        AUTHORS:<br/>
        Phillip Nam, Kevin Sangurima, Ryan Clark, James Jacobson, Neel Bains<br/>
        Spring 2021<br/>


      </div>
    </div>
    
    <script type="module">
      // ============================================================================
      import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js'; // ThreeJS module
      import { PointerLockControls } from './PointerLockControls.js'; // Module that allows for movement controls
      // ============================================================================

      let camera, scene, renderer; // The main three components
      let controls; // Controller for navigation
      let copperBall, silverBall, die1, die2; // Object meshes (simpler)
      let snowman, desk, lamp, wallPicture; // Object meshes (Multiple parts)
      let dz = 0.01; // How much more the snowman is tilting each iteration
      let floorMesh, ceilingMesh, northWallMesh, southWallMesh, eastWallMesh, westWallMesh; // Meshes for constructing the room
      const FLOOR_WIDTH = 120; // The dimensions of the floor
      const FLOOR_DEPTH = 120;

      // Light variables
      const LIGHT_HEIGHT = 60; // Height for RGB lights
      let redIntensity = 1;
      let greenIntensity = 1;
      let blueIntensity = 1;
      let lampIntensity = 1;
      let flashlightIntensity = 1; // Camera flashlight

      // Flags for lighting effect (on/off)
      let is_red_light = true;
      let is_green_light = true;
      let is_blue_light = true;
      let is_lamp_light = true;
      let is_camera_light = true;

      // Movement variables
      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      let previousAnimationTime = performance.now();

      let moveDirection = new THREE.Vector3();   // The direction to move in camera's view (based on keyboard input)
      let moveSpeed = 30; // Feet per second to move (average walking speed is 4.6 ft/sec)

      // Camera Bounds (Since room is square, only need one min and one max)
      let BOUND_MIN = -58;
      let BOUND_MAX = 58;
        
      let diceRoll = false;
      
      init();
      animate();

      function init() {
          // Create and set up the camera
          camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
          camera.position.z = 55;
          camera.position.y = 30;

          // Create and set up the Scene
          scene = new THREE.Scene();

          // Create the room
          createRoom(scene);
          
          // Set up lighting
          setupRedLighting(scene);
          setupGreenLighting(scene);
          setupBlueLighting(scene);
          setupCameraLighting(scene);

          // Draw the objects
        //   createSnowman(scene);
          createDesk(scene);
          createCopperBall(scene);
          createSilverBall(scene);
          createLamp(scene);
          createDie1(scene);
          createDie2(scene);
          die2.position.x -= 4;
          die2.position.z += 5;
          createWallPicture(scene);
          
          // Set up the navigation controls
          setupNavigation(scene);
          
          // Create and set up the Renderer
	  renderer = new THREE.WebGLRenderer({ antialias: true });
	  renderer.setPixelRatio(window.devicePixelRatio);
	  renderer.setSize(window.innerWidth, window.innerHeight);
	  document.body.appendChild(renderer.domElement);

	  window.addEventListener( 'resize', onWindowResize );
      }

      function setupNavigation(parent) {
          controls = new PointerLockControls(camera, document.body);
          parent.add(controls.getObject());
          
          // Set up the key listeners
          const onKeyDown = function (event) {
            switch (event.code) {
            case 'KeyW':
            moveForward = true;
            break;

            case 'KeyA':
            moveLeft = true;
            break;

            case 'KeyS':
            moveBackward = true;
            break;

            case 'KeyD':
            moveRight = true;
            break;

            case 'ShiftLeft':
            moveSpeed = 60; // Holding shift increases movement speed
            break;

            // DEBUG
            case 'NumpadAdd':
            camera.position.y += 1;
            break;

            // DEBUG
            case 'NumpadSubtract':
            camera.position.y -= 1;
            break;

            case 'KeyR':
            camera.position.set(0, 30, 55);
            break;

            case 'Digit1':
            if (is_red_light == true) {
                is_red_light = false;
                redIntensity = 0;
            }
            break;

            }
        };

         const onKeyPress = function (event) {
            switch ( event.code ) {
            case 'Digit0':
            case 'Numpad0':
            console.log("Key pressed");
            if (is_red_light == true) {
                is_red_light = false;
                redIntensity = 0;
                console.log("Red light is false");
            }
            else if (is_red_light == false) {
                is_red_light = true;
                redIntensity = 1;
                console.log("Red light is true");
            }
            break;

            case 'Digit1':
            case 'Numpad1':
            if (is_red_light == true) {
                is_red_light = false;
                redIntensity = 0;
            }
            break;

            case 'Digit2':
            case 'Numpad2':
            if (is_red_light == true) {
                is_red_light = false;
                redIntensity = 0;
            }
            break;

            case 'Digit3':
            case 'Numpad3':
            if (is_red_light == true) {
                is_red_light = false;
                redIntensity = 0;
            }
            break;

            case 'Digit4':
            case 'Numpad4':
            if (is_red_light == true) {
                is_red_light = false;
                redIntensity = 0;
            }
            break;
            
            case'KeyL':
            diceRoll = !diceRoll;

            }
	  };

         const onKeyUp = function (event) {
            switch ( event.code ) {
            case 'KeyW':
            moveForward = false;
            break;
                    
            case 'KeyA':
            moveLeft = false;
            break;
                    
            case 'KeyS':
            moveBackward = false;
            break;
                    
            case 'KeyD':
            moveRight = false;
            break;
            
            case 'ShiftLeft':
            moveSpeed = 30;
            break;
            }
	  };

	  document.addEventListener( 'keydown', onKeyDown );
      document.addEventListener( 'keypress', onKeyPress);
	  document.addEventListener( 'keyup', onKeyUp );

          // Let us grab the Mouse controls from the DOM.
          // We do this using the Pointer Lock API BUT grabbing the pointer is
          // not allowed until user interacts with the program - e.g. via a mouse click.
          // So, we need to set up such a gesture.  Using the PointerLock example from Three.js here.
	  const blocker = document.getElementById('blocker');
	  const instructions = document.getElementById('instructions');
	  instructions.addEventListener('click', function () {
              controls.lock();  // Lock the controls -- REQUESTS that the pointer be locked on this document.
              // The PointerLockControls class handles the mouse motion for looking but not the movement via keyboard controls
              // The lock can only be grabbed IF this event is processed.
	  } );

	  controls.addEventListener('lock', function () {
              // If the lock happens, we can hide the instructions and the blocker
	      instructions.style.display = 'none';
	      blocker.style.display = 'none';
	  } );

	  controls.addEventListener( 'unlock', function () {
	      blocker.style.display = 'block';
	      instructions.style.display = '';
	  } );
      }
      
      function setupRedLighting(parent) {
          var x = -25;
          var z = -20;
              var lightColor = 0xFF3333;
              var light = new THREE.PointLight( lightColor, redIntensity, 100 );
              light.position.set(x, LIGHT_HEIGHT, z);
              parent.add(light);
            //   parent.add( new THREE.AmbientLight(0x111100) );
              parent.add( new THREE.AmbientLight(0x330B0B) );
              
              // Draw a sphere to represent the light source
              const geometry = new THREE.SphereGeometry(1, 10, 10); // Create the Sphere Geometry
              const mat = new THREE.MeshPhongMaterial( {
                  color: 0xFF0000,          // reflectivity for diffuse and ambient light
                  emissive: lightColor,     // emission color; a very small amount of red (in case my lighting is not working really)
                  specular: 0x000000,       // reflectivity for specular light
                  shininess: 1              // controls size of specular highlights
              } );
              var lightMesh = new THREE.Mesh( geometry, mat );
              lightMesh.position.set(x, LIGHT_HEIGHT, z);
              parent.add(lightMesh);
      }

      function setupGreenLighting(parent) {
          var x = 0;
          var z = 20;
              var lightColor = 0x1CF51C;
              var light = new THREE.PointLight( lightColor, greenIntensity, 100 );
              light.position.set(x, LIGHT_HEIGHT, z);
              parent.add(light);
              parent.add( new THREE.AmbientLight(0x0D370D) );
              
              // Draw a sphere to represent the light source
              const geometry = new THREE.SphereGeometry(1, 10, 10); // Create the Sphere Geometry
              const mat = new THREE.MeshPhongMaterial( {
                  color: 0x00FF00,          // reflectivity for diffuse and ambient light
                  emissive: lightColor,     // emission color; a very small amount of red (in case my lighting is not working really)
                  specular: 0x000000,       // reflectivity for specular light
                  shininess: 1              // controls size of specular highlights
              } );
              var lightMesh = new THREE.Mesh( geometry, mat );
              lightMesh.position.set(x, LIGHT_HEIGHT, z);
              parent.add(lightMesh);
      }

      function setupBlueLighting(parent) {
          var x = 25;
          var z = -20;
              var lightColor = 0x1D4BF6;
              var light = new THREE.PointLight( lightColor, blueIntensity, 100 );
              light.position.set(x, LIGHT_HEIGHT, z);
              parent.add(light);
              parent.add( new THREE.AmbientLight(0x121245) );
              
              // Draw a sphere to represent the light source
              const geometry = new THREE.SphereGeometry(1, 10, 10); // Create the Sphere Geometry
              const mat = new THREE.MeshPhongMaterial( {
                  color: 0x0000FF,          // reflectivity for diffuse and ambient light
                  emissive: lightColor,     // emission color; a very small amount of red (in case my lighting is not working really)
                  specular: 0x000000,       // reflectivity for specular light
                  shininess: 1              // controls size of specular highlights
              } );
              var lightMesh = new THREE.Mesh( geometry, mat );
              lightMesh.position.set(x, LIGHT_HEIGHT, z);
              parent.add(lightMesh);
      }

      function setupCameraLighting(parent) {
            //   var lightColor = 0xcccc99;
              var lightColor = 0xFFFFFF;
              var light = new THREE.PointLight( lightColor, flashlightIntensity, 100 );
              light.position.set( camera.position ); // Flashlight follows the camera's position
              parent.add(light);
              parent.add( new THREE.AmbientLight(0x111100) );
              
              // Draw a sphere to represent the light source
              const geometry = new THREE.SphereGeometry(0.6, 10, 10); // Create the Sphere Geometry
              const mat = new THREE.MeshPhongMaterial( {
                  color: 0xFFFFFF,          // reflectivity for diffuse and ambient light
                  emissive: lightColor,     // emission color; a very small amount of red (in case my lighting is not working really)
                  specular: 0x000000,       // reflectivity for specular light
                  shininess: 1              // controls size of specular highlights
              } );
              var lightMesh = new THREE.Mesh( geometry, mat );
              lightMesh.position.set(camera.position); // Ball follows camera
              parent.add(lightMesh);
      }

      // Create a room and add it to the parent object
      function createRoom(parent) {
          // Load textures
          const woodFloorTexture = new THREE.TextureLoader().load('textures/woodFloor.jpg'); // Wood
          const ceilingTexture = new THREE.TextureLoader().load('textures/ceiling.jpg'); // Ceiling
          const brickTexture = new THREE.TextureLoader().load('textures/brickWall.jpg'); // Brick

           // Create the geometry
          const floor = new THREE.PlaneGeometry(FLOOR_WIDTH, FLOOR_DEPTH, 10*FLOOR_WIDTH, 10*FLOOR_DEPTH);
          const wall = new THREE.PlaneGeometry(FLOOR_WIDTH, 70, 10*FLOOR_WIDTH, 10*FLOOR_DEPTH);

          // Allow the materials to have light properties
          const matWood = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for ßspecular light
              shininess: 50,      // controls size of specular highlights
              map: woodFloorTexture
          } );
          const matCeiling = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for specular light
              shininess: 30,      // controls size of specular highlights
              map: ceilingTexture
          } );
          const matBrick = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for specular light
              shininess: 20,      // controls size of specular highlights
              map: brickTexture
          } );

          // Setting up meshes
          // Floor Mesh
          floorMesh = new THREE.Mesh( floor, matWood );
          floorMesh.rotation.x = -Math.PI/2;   // Rotate floor to be horizontal
          
          // Ceiling Mesh
          ceilingMesh = new THREE.Mesh( floor, matCeiling);
          ceilingMesh.rotation.x = Math.PI/2;   // Rotate floor to be horizontal
          ceilingMesh.position.y = 70;   // Rotate floor to be horizontal

          // North Wall Mesh
          northWallMesh = new THREE.Mesh( wall, matBrick);
          northWallMesh.position.z = -60;
          northWallMesh.position.y = 35;

          // South Wall Mesh
          southWallMesh = new THREE.Mesh( wall, matBrick);
          southWallMesh.rotation.y = Math.PI;
          southWallMesh.position.z = 60;
          southWallMesh.position.y = 35;

          // East Wall Mesh
          eastWallMesh = new THREE.Mesh( wall, matBrick);
          eastWallMesh.rotation.y = -Math.PI/2;
          eastWallMesh.position.x = 60;
          eastWallMesh.position.y = 35;

          // West Wall Mesh
          westWallMesh = new THREE.Mesh( wall, matBrick);
          westWallMesh.rotation.y = Math.PI/2;
          westWallMesh.position.x = -60;
          westWallMesh.position.y = 35;

          // Adding meshes to parent
          parent.add(floorMesh);
          parent.add(ceilingMesh);
          parent.add(northWallMesh);
          parent.add(southWallMesh);
          parent.add(eastWallMesh);
          parent.add(westWallMesh);
      }

      function createDesk(parent) {
        desk = new THREE.Object3D();

          // Load textures
          const woodTexture = new THREE.TextureLoader().load('textures/wood.png'); // Wood

          const matWood = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for ßspecular light
              shininess: 40,      // controls size of specular highlights
              map: woodTexture
          } );

           // Create the geometries
          const boxGeometry = new THREE.BoxGeometry(40, 2, 25); // For table top
          const cylinderGeometry = new THREE.CylinderGeometry( 2, 1, 12, 4 ); // For table leg

          // Creating and setting up meshes
          // Table Top
          const tableTop = new THREE.Mesh(boxGeometry, matWood);
          desk.add(tableTop);
          tableTop.position.y = 13;
          
          // Table Leg (NE)
          const tableLeg1 = new THREE.Mesh(cylinderGeometry, matWood);
          desk.add(tableLeg1);
          tableLeg1.position.x = 15;
          tableLeg1.position.y = 6;
          tableLeg1.position.z = -8;
          
          // Table Leg (SE)
          const tableLeg2 = new THREE.Mesh(cylinderGeometry, matWood);
          desk.add(tableLeg2);
          tableLeg2.position.x = 15;
          tableLeg2.position.y = 6;
          tableLeg2.position.z = 7;
          
          // Table Leg (SW)
          const tableLeg3 = new THREE.Mesh(cylinderGeometry, matWood);
          desk.add(tableLeg3);
          tableLeg3.position.x = -15;
          tableLeg3.position.y = 6;
          tableLeg3.position.z = 7;
          
          // Table Leg (NW)
          const tableLeg4 = new THREE.Mesh(cylinderGeometry, matWood);
          desk.add(tableLeg4);
          tableLeg4.position.x = -15;
          tableLeg4.position.y = 6;
          tableLeg4.position.z = -8;

          // Adding desk mesh to parent
          parent.add(desk);
      }
      
      function createSnowman(parent) {
          // The holder for our snowman object
          snowman = new THREE.Object3D();

          // Set the material property for the ball
          const snowManMat = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x200000,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x828282,  // reflectivity for specular light
              shininess: 100       // controls size of specular highlights
          } );

          // Create the base of the snowman
          const baseGeometry = new THREE.SphereGeometry(3, 20, 20);
          const midGeometry = new THREE.SphereGeometry(2, 20, 20);
          const headGeometry = new THREE.SphereGeometry(1, 20, 20);

          const baseMesh = new THREE.Mesh(baseGeometry, snowManMat);
          const midMesh = new THREE.Mesh(midGeometry, snowManMat);
          const headMesh = new THREE.Mesh(headGeometry, snowManMat);

          snowman.add(baseMesh);
          baseMesh.position.y = 3;
          snowman.add(midMesh);
          midMesh.position.y = 8;
          snowman.add(headMesh);
          headMesh.position.y = 11;

          parent.add(snowman);
      }
      
      function createCopperBall(parent) {
          // Create the Sphere Geometry
          const geometry = new THREE.SphereGeometry(0.7, 20, 20);

          // Set the material property for the ball
          const mat = new THREE.MeshPhongMaterial( {
              color: 0xDF7109,     // reflectivity for diffuse and ambient light
              emissive: 0x200000,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x828282,  // reflectivity for specular light
              shininess: 50       // controls size of specular highlights
          } );
          
          // Set up the mesh and add it to the scene
          copperBall = new THREE.Mesh( geometry, mat );
          copperBall.position.x = -10;
          copperBall.position.y = 14.7;
          copperBall.position.z = -6;
          parent.add(copperBall);
      }

      function createSilverBall(parent) {
          // Create the Sphere Geometry
          const geometry = new THREE.SphereGeometry(0.7, 20, 20);

          // Set the material property for the ball
          const mat = new THREE.MeshPhongMaterial( {
              color: 0x8A8881,     // reflectivity for diffuse and ambient light
              emissive: 0x200000,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x828282,  // reflectivity for specular light
              shininess: 100       // controls size of specular highlights
          } );
          
          // Set up the mesh and add it to the scene
          silverBall = new THREE.Mesh( geometry, mat );
          silverBall.position.x = -10;
          silverBall.position.y = 14.7;
          silverBall.position.z = 6;
          parent.add(silverBall);
      }

      function createLamp(parent) {
          lamp = new THREE.Object3D();
          var lightColor = 0xEBFE65;

          // Set up the material
        const matLamp = new THREE.MeshPhongMaterial( {
              color: 0x2C2C2C,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for ßspecular light
              shininess: 10,      // controls size of specular highlights
          } );
          const matLight = new THREE.MeshPhongMaterial( {
                  color: 0xF1FE86,          // reflectivity for diffuse and ambient light
                  emissive: lightColor,     // emission color; a very small amount of red (in case my lighting is not working really)
                  specular: 0x000000,       // reflectivity for specular light
                  shininess: 1              // controls size of specular highlights
              } );

              // Create Lamp Light Source
              var light = new THREE.PointLight( lightColor, lampIntensity, 100 );
              light.position.set(2, 20.5, -1);
              lamp.add(light);
              lamp.add( new THREE.AmbientLight(0x111100) );

           // Create the geometries
          const cylinderThin = new THREE.CylinderGeometry( 0.1, 0.1, 5, 10 ); // For lamp mid
          const cylinderWide = new THREE.CylinderGeometry( 2, 2, 0.5, 10 ); // For lamp base
          const box = new THREE.BoxGeometry(1.3, 0.3, 2.6); // For lamp light hood
          const boxLight = new THREE.BoxGeometry(1.1, 0.15, 1.7); // For lamp light

          // Create meshes
          const lampBase = new THREE.Mesh(cylinderWide, matLamp);
          const lampMid1 = new THREE.Mesh(cylinderThin, matLamp);
          const lampMid2 = new THREE.Mesh(cylinderThin, matLamp);
          const lampHood = new THREE.Mesh(box, matLamp);
          const lampLight = new THREE.Mesh(boxLight, matLight); // Represents the lamp light source

          // Add meshes to lamp and set them up
          lamp.add(lampBase);
          lampBase.position.x = 2;
          lampBase.position.y = 14;
          lampBase.position.z = -5;

          lamp.add(lampMid1);
          lampMid1.position.x = 2;
          lampMid1.position.y = 16.7;
          lampMid1.position.z = -5;

          lamp.add(lampMid2);
          lampMid2.rotation.x = Math.PI/3;
          lampMid2.position.x = 2;
          lampMid2.position.y = 19.4;
          lampMid2.position.z = -4;

          lamp.add(lampHood);
          lampHood.position.x = 2;
          lampHood.position.y = 20.7;
          lampHood.position.z = -1.3;

          lamp.add(lampLight);
          lampLight.position.x = 2;
          lampLight.position.y = 20.5;
          lampLight.position.z = -1.0;

          // Add meshes to parent
          parent.add(lamp);
      }

      function createDie1(parent) {
          die1 = new THREE.Object3D();

          // Load 6 textures for die faces
          const face1Texture = new THREE.TextureLoader().load('textures/dice/face1.jpg');
          const face2Texture = new THREE.TextureLoader().load('textures/dice/face2.jpg');
          const face3Texture = new THREE.TextureLoader().load('textures/dice/face3.jpg');
          const face4Texture = new THREE.TextureLoader().load('textures/dice/face4.jpg');
          const face5Texture = new THREE.TextureLoader().load('textures/dice/face5.jpg');
          const face6Texture = new THREE.TextureLoader().load('textures/dice/face6.jpg');

          // Create face materials
          const matFace1 = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for ßspecular light
              shininess: 30,      // controls size of specular highlights
              map: face1Texture,
              side: THREE.DoubleSide
          } );
          const matFace2 = new THREE.MeshPhongMaterial( {
              color: 0x808080,
              emissive: 0x010101,
              specular: 0x101010,
              shininess: 30,
              map: face2Texture,
              side: THREE.DoubleSide
          } );
          const matFace3 = new THREE.MeshPhongMaterial( {
              color: 0x808080,
              emissive: 0x010101,
              specular: 0x101010,
              shininess: 30,
              map: face3Texture,
              side: THREE.DoubleSide
          } );
          const matFace4 = new THREE.MeshPhongMaterial( {
              color: 0x808080,
              emissive: 0x010101,
              specular: 0x101010,
              shininess: 30,
              map: face4Texture,
              side: THREE.DoubleSide
          } );
          const matFace5 = new THREE.MeshPhongMaterial( {
              color: 0x808080,
              emissive: 0x010101,
              specular: 0x101010,
              shininess: 30,
              map: face5Texture,
              side: THREE.DoubleSide
          } );
          const matFace6 = new THREE.MeshPhongMaterial( {
              color: 0x808080,
              emissive: 0x010101,
              specular: 0x101010,
              shininess: 30,
              map: face6Texture,
              side: THREE.DoubleSide
          } );

          // Create the geometry
          const facePlane = new THREE.PlaneGeometry(1.5, 1.5, 20, 20); // For lamp light hood
          // Create face meshes
          const face1 = new THREE.Mesh( facePlane, matFace1);
          const face2 = new THREE.Mesh( facePlane, matFace2);
          const face3 = new THREE.Mesh( facePlane, matFace3);
          const face4 = new THREE.Mesh( facePlane, matFace4);
          const face5 = new THREE.Mesh( facePlane, matFace5);
          const face6 = new THREE.Mesh( facePlane, matFace6);

          // Add meshes to die1 and set them up
          //Bottom
          die1.add(face1)
          face1.rotation.x = Math.PI/2;
          face1.position.x = 0;
          face1.position.y = -.75;
          face1.position.z = 0;

          // Top
          die1.add(face2)
          face2.rotation.x = Math.PI/2;
          face2.position.x = 0;
          face2.position.y = .75;
          face2.position.z = 0;

          // West Face
          die1.add(face3)
          face3.rotation.y = Math.PI/2;
          face3.position.x = -.75;
          face3.position.y = 0;
          face3.position.z = 0;

          // East Face
          die1.add(face4)
          face4.rotation.y = Math.PI/2;
          face4.position.x = .75;
          face4.position.y = 0;
          face4.position.z = 0;

          // North Face
          die1.add(face5)
          face5.position.x = 0;
          face5.position.y = 0;
          face5.position.z = .75;

          // South Face
          die1.add(face6)
          face6.position.x = 0;
          face6.position.y = 0;
          face6.position.z = -.75;

          die1.position.set(15, 15, 2);
          parent.add(die1);
      }

      function createDie2(parent) {
          die2 = new THREE.Object3D();

          // Load 6 textures for die faces
          const face1Texture = new THREE.TextureLoader().load('textures/dice/die-0.png');
          const face2Texture = new THREE.TextureLoader().load('textures/dice/die-1.png');
          const face3Texture = new THREE.TextureLoader().load('textures/dice/die-2.png');
          const face4Texture = new THREE.TextureLoader().load('textures/dice/die-3.png');
          const face5Texture = new THREE.TextureLoader().load('textures/dice/die-4.png');
          const face6Texture = new THREE.TextureLoader().load('textures/dice/die-5.png');

          // Create face materials
          const matFace1 = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for ßspecular light
              shininess: 30,      // controls size of specular highlights
              map: face1Texture,
              side: THREE.DoubleSide
          } );
          const matFace2 = new THREE.MeshPhongMaterial( {
              color: 0x808080,
              emissive: 0x010101,
              specular: 0x101010,
              shininess: 30,
              map: face2Texture,
              side: THREE.DoubleSide
          } );
          const matFace3 = new THREE.MeshPhongMaterial( {
              color: 0x808080,
              emissive: 0x010101,
              specular: 0x101010,
              shininess: 30,
              map: face3Texture,
              side: THREE.DoubleSide
          } );
          const matFace4 = new THREE.MeshPhongMaterial( {
              color: 0x808080,
              emissive: 0x010101,
              specular: 0x101010,
              shininess: 30,
              map: face4Texture,
              side: THREE.DoubleSide
          } );
          const matFace5 = new THREE.MeshPhongMaterial( {
              color: 0x808080,
              emissive: 0x010101,
              specular: 0x101010,
              shininess: 30,
              map: face5Texture,
              side: THREE.DoubleSide
          } );
          const matFace6 = new THREE.MeshPhongMaterial( {
              color: 0x808080,
              emissive: 0x010101,
              specular: 0x101010,
              shininess: 30,
              map: face6Texture,
              side: THREE.DoubleSide
          } );

          // Create the geometry
          const facePlane = new THREE.PlaneGeometry(1.5, 1.5, 20, 20); // For lamp light hood
          // Create face meshes
          const face1 = new THREE.Mesh( facePlane, matFace1);
          const face2 = new THREE.Mesh( facePlane, matFace2);
          const face3 = new THREE.Mesh( facePlane, matFace3);
          const face4 = new THREE.Mesh( facePlane, matFace4);
          const face5 = new THREE.Mesh( facePlane, matFace5);
          const face6 = new THREE.Mesh( facePlane, matFace6);

          // Add meshes to die2 and set them up
          //Bottom
          die2.add(face1)
          face1.rotation.x = Math.PI/2;
          face1.position.x = 0;
          face1.position.y = -.75;
          face1.position.z = 0;

          // Top
          die2.add(face2)
          face2.rotation.x = Math.PI/2;
          face2.position.x = 0;
          face2.position.y = .75;
          face2.position.z = 0;

          // West Face
          die2.add(face3)
          face3.rotation.y = Math.PI/2;
          face3.position.x = -.75;
          face3.position.y = 0;
          face3.position.z = 0;

          // East Face
          die2.add(face4)
          face4.rotation.y = Math.PI/2;
          face4.position.x = .75;
          face4.position.y = 0;
          face4.position.z = 0;

          // North Face
          die2.add(face5)
          face5.position.x = 0;
          face5.position.y = 0;
          face5.position.z = .75;

          // South Face
          die2.add(face6)
          face6.position.x = 0;
          face6.position.y = 0;
          face6.position.z = -.75;

          die2.position.set(14, 15, 2);
          parent.add(die2);
      }

      function createWallPicture(parent) {
          // Load textures
          const libraryTexture = new THREE.TextureLoader().load('textures/library.jpg');

           // Create the geometry
          const plane = new THREE.PlaneGeometry(50, 30, 30, 30);

          // Allow the materials to have light properties
          const mat = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for ßspecular light
              shininess: 30,      // controls size of specular highlights
              map: libraryTexture,
              side: THREE.DoubleSide
          } );

          // Set up mesh
          wallPicture = new THREE.Mesh( plane, mat);
          wallPicture.position.y = 32;
          wallPicture.position.z = -59.5;


          parent.add(wallPicture);
      }

      // On a window resize, recompute the camera's aspect ratio and then update the project matrix based on that.
      function onWindowResize() {
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();

	  renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
	  requestAnimationFrame(animate);  // Request another call to animation frame (as soon as possible)

          // How much time has elapsed since the last animation frame?  (Used for steadier speed)
          const currentTime = performance.now();
          const delta = (currentTime - previousAnimationTime)/1000.0;   // Elapsed time in seconds
          previousAnimationTime = currentTime;

          // Adjust movement (assuming we have locked the mouse pointer to the document)
          if (controls.isLocked) adjustMovement(delta);
         
        if (diceRoll){
            die1.rotation.x -= 0.1;
            die1.rotation.y -= 0.1;
            die1.rotation.z -= 0.1;
            die2.rotation.x -= 0.1;
            die2.rotation.y -= 0.1;
            die2.rotation.z -= 0.1;
        }  

          // Rotate the mesh object in the x and y and z directions a bit.
	//   snowman.rotation.z += dz;
    //       if (snowman.rotation.z < -0.5) {
    //           snowman.rotation.z = -0.5;
    //           dz = -dz;
    //       } else if (snowman.rotation.z > 0.5) {
    //           snowman.rotation.z = 0.5;
    //           dz = -dz;
    //       }

          // And now render the scene using the camera
          //    The renderer does all the set up and calling
	  renderer.render(scene, camera);
      }

      // Adjust the camera's position based on keys pressed
      function adjustMovement(delta) {
          // Compute the direction to move based on the WASD keys pressed
          moveDirection.x = Number(moveRight) - Number(moveLeft);  // Since the keyboard allows pushing both at same time (they can cancel each other)
          moveDirection.z = Number(moveForward) - Number(moveBackward);
          moveDirection.normalize();   // Make sure that the direction is of unit length (so diagonal is not faster)

          // Check if the camera is touching the scene boundaries
          if (camera.position.x >= BOUND_MAX) {
              camera.position.x = BOUND_MAX;
          }
          if (camera.position.x <= BOUND_MIN) {
              camera.position.x = BOUND_MIN;
          }
          if (camera.position.z >= BOUND_MAX) {
              camera.position.z = BOUND_MAX;
          }
          if (camera.position.z <= BOUND_MIN) {
              camera.position.z = BOUND_MIN;
          }

          controls.moveRight(moveDirection.x*moveSpeed*delta);
          controls.moveForward(moveDirection.z*moveSpeed*delta);
      }
    </script>

  </body>
</html>
