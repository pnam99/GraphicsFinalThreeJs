<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - 3D Scene</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>
  <body>
    <!-- See main.css for #info and #overlay for the markup attributes for it -->
    <div id="info">Welcome To Our 3D Scene!</div>
    <!-- <div id="overlay">This is an overlay example.</div>  <!-- Uncomment if you want to see an overlay text -->
    <script type="module">
      // ============================================================================
      // Import three.js module
      import * as THREE from "https://unpkg.com/three@0.128.0/build/three.module.js";
      import { PointerLockControls } from './PointerLockControls.js';
      // ============================================================================

      // Global Variables
      let camera, scene, renderer; // The main three components
      let floorMesh, ceilingMesh, northWallMesh, southWallMesh, eastWallMesh, westWallMesh, room; // Room construction meshes
      let tableMesh, silverBallMesh, copperBallMesh, dieMesh, lampMesh; // Object Meshes

      init();
      animate();

      function init() {
        // Create and set up the camera (Smaller (shallow) angle = zoomed in, Larger = zoomed out)
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.y = 70; // Raise camera
        camera.position.z = 350; // Decent distance away from box
        
        // Create and set up the Scene
        scene = new THREE.Scene(); // We will add to the scene as we create more objects

        // Create geometries

        // Load textures

        // Set up materials

        // Create and set up meshes
        
        // Draw objects to scene
        // drawFloorPlane(scene); // Floor
        // drawCeilingPlane(scene); // Ceiling
        // ceilingMesh.position.y += 200;

        drawRoom(scene);

        // drawWallPlane(scene, northWallMesh);
        // northWallMesh

        drawCopperBall(scene);

        // Add lights to the scene
        setupRedLighting(scene);

        // Create and set up the Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener("resize", onWindowResize); // Updates the screen (rescales the aspect ratio) when window is resized
      }

      function setupNavigation(parent) {
          controls = new PointerLockControls(camera, document.body);
        parent.add(controls.getObject());

            // Set up the key listeners
        const onKeyDown = function (event) {
            switch (event.code) {
            case 'ArrowUp':
            case 'KeyW':
            moveForward = true;
            break;

            case 'ArrowLeft':
            case 'KeyA':
            moveLeft = true;
            break;
                    
            case 'ArrowDown':
            case 'KeyS':
            moveBackward = true;
            break;
                    
            case 'ArrowRight':
            case 'KeyD':
            moveRight = true;
            break;

            }
        };

        const onKeyUp = function (event) {
            switch ( event.code ) {
            case 'ArrowUp':
            case 'KeyW':
            moveForward = false;
            break;
                    
            case 'ArrowLeft':
            case 'KeyA':
            moveLeft = false;
            break;
                    
            case 'ArrowDown':
            case 'KeyS':
            moveBackward = false;
            break;
                    
            case 'ArrowRight':
            case 'KeyD':
            moveRight = false;
            break;
                    
            }
        };

        document.addEventListener( 'keydown', onKeyDown );
        document.addEventListener( 'keyup', onKeyUp );

            // Let us grab the Mouse controls from the DOM.
            // We do this using the Pointer Lock API BUT grabbing the pointer is
            // not allowed until user interacts with the program - e.g. via a mouse click.
            // So, we need to set up such a gesture.  Using the PointerLock example from Three.js here.
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        instructions.addEventListener('click', function () {
                controls.lock();  // Lock the controls -- REQUESTS that the pointer be locked on this document.
                // The PointerLockControls class handles the mouse motion for looking but not the movement via keyboard controls
                // The lock can only be grabbed IF this event is processed.
        } );

        controls.addEventListener('lock', function () {
                // If the lock happens, we can hide the instructions and the blocker
            instructions.style.display = 'none';
            blocker.style.display = 'none';
        } );

        controls.addEventListener( 'unlock', function () {
            blocker.style.display = 'block';
            instructions.style.display = '';
        } );
      }

      function setupRedLighting(parent) {
            var lightColor = 0xff0000;
            var light = new THREE.PointLight( lightColor, 1, 100 );
            light.position.set(0, 100, 5);
            parent.add(light);
            parent.add( new THREE.AmbientLight(0x111100) );
              
            // Make the light "visible"
            // Create the Sphere Geometry
            const geometry = new THREE.SphereGeometry(5, 10, 10);
            const mat = new THREE.MeshPhongMaterial( {
                color: 0xff0000,     // reflectivity for diffuse and ambient light
                emissive: lightColor,  // emission color; a very small amount of red (in case my lighting is not working really)
                specular: 0x000000,  // reflectivity for specular light
                shininess: 1       // controls size of specular highlights
            } );
            var lightMesh = new THREE.Mesh( geometry, mat );
            lightMesh.position.set(0, 100, 5);
            parent.add(lightMesh);
      }

      function drawFloorPlane(parent) {
        const geometry = new THREE.PlaneGeometry(350, 250, 30); // Create Plane
        const loadWoodFloorTexture = new THREE.TextureLoader().load("textures/woodFloor.jpg"); // Load texture
        const woodFloorMaterial = new THREE.MeshBasicMaterial({ map: loadWoodFloorTexture, side: THREE.DoubleSide }); // Create wood material

        floorMesh = new THREE.Mesh(geometry, woodFloorMaterial); // Create mesh using geometry and material
        floorMesh.rotation.x = Math.PI/2;
        parent.add(floorMesh); // Add mesh to scene (parent)
      }

      function drawCeilingPlane(parent) {
        const geometry = new THREE.PlaneGeometry(350, 250, 30); // Create Plane
        const loadCeilingTexture = new THREE.TextureLoader().load("textures/ceiling.jpg"); // Load texture
        const ceilingMaterial = new THREE.MeshBasicMaterial({ map: loadCeilingTexture, side: THREE.DoubleSide }); // Create ceiling material

        ceilingMesh = new THREE.Mesh(geometry, ceilingMaterial); // Create mesh using geometry and material
        ceilingMesh.rotation.x = Math.PI/2;
        parent.add(ceilingMesh); // Add mesh to scene (parent)
      }

      function drawWallPlane(parent, planeMesh) {
        const geometry = new THREE.PlaneGeometry(350, 200, 30); // Create Plane
        const loadBrickTexture = new THREE.TextureLoader().load("textures/brickWall.jpg"); // Load texture
        const brickMaterial = new THREE.MeshBasicMaterial({ map: loadBrickTexture, side: THREE.DoubleSide }); // Create ceiling material

        planeMesh = new THREE.Mesh(geometry, brickMaterial); // Create mesh using geometry and material
        parent.add(planeMesh); // Add planeMesh to scene (parent)
      }

      function drawRoom(parent) {
          room = new THREE.Object3D();

          // Create the geometry of the room
          const horizontalPlane = new THREE.PlaneGeometry(350, 350, 30); // Geometry for floor and ceiling
          const verticalPlane = new THREE.PlaneGeometry(350, 200, 30); // Geometry for walls

          // Load textures and create materials
          const loadWoodFloorTexture = new THREE.TextureLoader().load("textures/woodFloor.jpg");
          const loadCeilingTexture = new THREE.TextureLoader().load("textures/ceiling.jpg");
          const loadBrickTexture = new THREE.TextureLoader().load("textures/brickWall.jpg");
          const woodFloorMaterial = new THREE.MeshBasicMaterial({ map: loadWoodFloorTexture, side: THREE.DoubleSide });
          const ceilingMaterial = new THREE.MeshBasicMaterial({ map: loadCeilingTexture, side: THREE.DoubleSide });
          const brickMaterial = new THREE.MeshBasicMaterial({ map: loadBrickTexture, side: THREE.DoubleSide });

          // Create the mesh for each wall
          const floor = new THREE.Mesh(horizontalPlane, woodFloorMaterial);
          const ceiling = new THREE.Mesh(horizontalPlane, ceilingMaterial);
          const northWall = new THREE.Mesh(verticalPlane, brickMaterial);
          const southWall = new THREE.Mesh(verticalPlane, brickMaterial);
          const eastWall = new THREE.Mesh(verticalPlane, brickMaterial);
          const westWall = new THREE.Mesh(verticalPlane, brickMaterial);

          // Add the meshes to the room object
          room.add(floor);
          floor.rotation.x += Math.PI/2;
          room.add(ceiling);
          ceiling.rotation.x += Math.PI/2;
          ceiling.position.y += 200;
          room.add(northWall);
          northWall.position.z -= 350;
          room.add(southWall);
          southWall.position.z += 350;
          room.add(eastWall);
          eastWall.rotation.y += Math.PI/2;
          room.add(westWall);
          westWall.rotation.y += Math.PI/2;


          parent.add(room);
        }

      function drawCopperBall(parent) {
          // Create the Sphere Geometry
          const geometry = new THREE.SphereGeometry(5, 20, 20);

          // Set the material property for the ball
          const mat = new THREE.MeshPhongMaterial( {
              color: 0xff9900,     // reflectivity for diffuse and ambient light
              emissive: 0x220000,  // emission color
              specular: 0x828282,  // reflectivity for specular light
              shininess: 100       // controls size of specular highlights
          } );
          
          // Create the mesh and add it to the scene
          //   We are making the ballMesh global so it can be altered by animation
          copperBallMesh = new THREE.Mesh( geometry, mat );
          parent.add(copperBallMesh);

      }

      // On a window resize, recompute the camera's aspect ratio and then update the project matrix based on that.
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate); // Request another call to animation frame (as soon as possible)

        // Rotate the mesh object in the x and y and z directions a bit.
        // mesh.rotation.x += 0.01;

        // Rotate copper ball
        copperBallMesh.rotation.y += 0.01;

        // And now render the scene using the camera
        //    The renderer does all the set up and calling
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
