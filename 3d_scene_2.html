<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - 3D Scene</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
  </head>
  <style>
    #blocker {
	position: absolute;
	width: 100%;
	height: 100%;
	background-color: rgba(0,0,0,0.5);
    }
    #instructions {
	width: 100%; height: 100%;
	display: -webkit-box; display: -moz-box; display: box;
        
	-webkit-box-orient: horizontal;	-moz-box-orient: horizontal; box-orient: horizontal;
	-webkit-box-pack: center; -moz-box-pack: center; box-pack: center;
        
	-webkit-box-align: center; -moz-box-align: center; box-align: center;
        
	color: #ffffff;
	text-align: center;
	font-family: Arial;
	font-size: 20px;
	line-height: 30px;
	cursor: pointer;
    }
  </style>
  
  <body>
    <!-- See main.css for #info and #overlay for the markup attributes for it -->
    <div id="info">Welcome to our home, once again!</div>
    <!-- <div id="overlay">This is an overlay example.</div>  Uncomment if you want to see an overlay text --> 
    <div id="blocker">
      <div id="instructions">
        <span style="font-size:30px">Click to move about</span>
        <br /><br />
        Move: WASD<br/>
        Look: MOUSE
      </div>
    </div>
    
    <script type="module">
      // ============================================================================
      import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js'; // ThreeJS module
      import { PointerLockControls } from './PointerLockControls.js'; // Module that allows for movement controls
      // ============================================================================

      let camera, scene, renderer; // The main three components
      let controls; // Controller for navigation
      let ballMesh;
      let snowman; // Object meshes
      let dz = 0.01; // How much more the snowman is tilting each iteration
      let floorMesh, ceilingMesh, northWallMesh, southWallMesh, eastWallMesh, westWallMesh; // Meshes for constructing the room
      const FLOOR_WIDTH = 120; // The dimensions of the floor
      const FLOOR_DEPTH = 120;
      const LIGHT_HEIGHT = 60;

      // Movement variables
      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      let previousAnimationTime = performance.now();

      let moveDirection = new THREE.Vector3();   // The direction to move in camera's view (based on keyboard input)
      let moveSpeed = 30; // Feet per second to move (average walking speed is 4.6 ft/sec)

      // Camera Bounds (Since room is square, only need one min and one max)
      let BOUND_MIN = -58;
      let BOUND_MAX = 58;
      
      init();
      animate();

      function init() {
          // Create and set up the camera
          camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
          camera.position.z = 55;
          camera.position.y = 30;

          // Create and set up the Scene
          scene = new THREE.Scene();

          // A simple snowman
          createSnowman(scene);

          // Create the room
          createRoom(scene);
          
          // Set up lighting
          setupRedLighting(scene);
          setupGreenLighting(scene);
          setupBlueLighting(scene);

          // Set up the navigation controls
          setupNavigation(scene);
          
          // Create and set up the Renderer
	  renderer = new THREE.WebGLRenderer({ antialias: true });
	  renderer.setPixelRatio(window.devicePixelRatio);
	  renderer.setSize(window.innerWidth, window.innerHeight);
	  document.body.appendChild(renderer.domElement);

	  window.addEventListener( 'resize', onWindowResize );
      }

      function setupNavigation(parent) {
          controls = new PointerLockControls(camera, document.body);
          parent.add(controls.getObject());
          
          // Set up the key listeners
          const onKeyDown = function (event) {
            switch (event.code) {
            case 'KeyW':
            moveForward = true;
            break;

            case 'KeyA':
            moveLeft = true;
            break;

            case 'KeyS':
            moveBackward = true;
            break;

            case 'KeyD':
            moveRight = true;
            break;
            }
        };

         const onKeyUp = function (event) {
            switch ( event.code ) {
            case 'KeyW':
            moveForward = false;
            break;
                    
            case 'KeyA':
            moveLeft = false;
            break;
                    
            case 'KeyS':
            moveBackward = false;
            break;
                    
            case 'KeyD':
            moveRight = false;
            break;  
            }
	  };

	  document.addEventListener( 'keydown', onKeyDown );
	  document.addEventListener( 'keyup', onKeyUp );

          // Let us grab the Mouse controls from the DOM.
          // We do this using the Pointer Lock API BUT grabbing the pointer is
          // not allowed until user interacts with the program - e.g. via a mouse click.
          // So, we need to set up such a gesture.  Using the PointerLock example from Three.js here.
	  const blocker = document.getElementById('blocker');
	  const instructions = document.getElementById('instructions');
	  instructions.addEventListener('click', function () {
              controls.lock();  // Lock the controls -- REQUESTS that the pointer be locked on this document.
              // The PointerLockControls class handles the mouse motion for looking but not the movement via keyboard controls
              // The lock can only be grabbed IF this event is processed.
	  } );

	  controls.addEventListener('lock', function () {
              // If the lock happens, we can hide the instructions and the blocker
	      instructions.style.display = 'none';
	      blocker.style.display = 'none';
	  } );

	  controls.addEventListener( 'unlock', function () {
	      blocker.style.display = 'block';
	      instructions.style.display = '';
	  } );
      }
      
      function setupRedLighting(parent) {
          var x = -25;
          var z = -20;
              var lightColor = 0xFF3333
              var light = new THREE.PointLight( lightColor, 1, 100 );
              light.position.set(x, LIGHT_HEIGHT, z);
              parent.add(light);
            //   parent.add( new THREE.AmbientLight(0x111100) );
              parent.add( new THREE.AmbientLight(0x330B0B) );
              
              // Draw a sphere to represent the light source
              const geometry = new THREE.SphereGeometry(1, 10, 10); // Create the Sphere Geometry
              const mat = new THREE.MeshPhongMaterial( {
                  color: 0xFF0000,          // reflectivity for diffuse and ambient light
                  emissive: lightColor,     // emission color; a very small amount of red (in case my lighting is not working really)
                  specular: 0x000000,       // reflectivity for specular light
                  shininess: 1              // controls size of specular highlights
              } );
              var lightMesh = new THREE.Mesh( geometry, mat );
              lightMesh.position.set(x, LIGHT_HEIGHT, z);
              parent.add(lightMesh);
      }

      function setupGreenLighting(parent) {
          var x = 0;
          var z = 20;
              var lightColor = 0x1CF51C
              var light = new THREE.PointLight( lightColor, 1, 100 );
              light.position.set(x, LIGHT_HEIGHT, z);
              parent.add(light);
              parent.add( new THREE.AmbientLight(0x0D370D) );
              
              // Draw a sphere to represent the light source
              const geometry = new THREE.SphereGeometry(1, 10, 10); // Create the Sphere Geometry
              const mat = new THREE.MeshPhongMaterial( {
                  color: 0x00FF00,          // reflectivity for diffuse and ambient light
                  emissive: lightColor,     // emission color; a very small amount of red (in case my lighting is not working really)
                  specular: 0x000000,       // reflectivity for specular light
                  shininess: 1              // controls size of specular highlights
              } );
              var lightMesh = new THREE.Mesh( geometry, mat );
              lightMesh.position.set(x, LIGHT_HEIGHT, z);
              parent.add(lightMesh);
      }

      function setupBlueLighting(parent) {
          var x = 25;
          var z = -20;
              var lightColor = 0x1D4BF6
              var light = new THREE.PointLight( lightColor, 1, 100 );
              light.position.set(x, LIGHT_HEIGHT, z);
              parent.add(light);
              parent.add( new THREE.AmbientLight(0x121245) );
              
              // Draw a sphere to represent the light source
              const geometry = new THREE.SphereGeometry(1, 10, 10); // Create the Sphere Geometry
              const mat = new THREE.MeshPhongMaterial( {
                  color: 0x0000FF,          // reflectivity for diffuse and ambient light
                  emissive: lightColor,     // emission color; a very small amount of red (in case my lighting is not working really)
                  specular: 0x000000,       // reflectivity for specular light
                  shininess: 1              // controls size of specular highlights
              } );
              var lightMesh = new THREE.Mesh( geometry, mat );
              lightMesh.position.set(x, LIGHT_HEIGHT, z);
              parent.add(lightMesh);
      }

      // Create a room and add it to the parent object
      function createRoom(parent) {
          // Load textures
          const woodFloorTexture = new THREE.TextureLoader().load('textures/woodFloor.jpg'); // Wood
          const ceilingTexture = new THREE.TextureLoader().load('textures/ceiling.jpg'); // Ceiling
          const brickTexture = new THREE.TextureLoader().load('textures/brickWall.jpg'); // Brick

           // Create the planes
          const floor = new THREE.PlaneGeometry(FLOOR_WIDTH, FLOOR_DEPTH, 10*FLOOR_WIDTH, 10*FLOOR_DEPTH);
          const wall = new THREE.PlaneGeometry(FLOOR_WIDTH, 70, 10*FLOOR_WIDTH, 10*FLOOR_DEPTH);

          // Allow the materials to have light properties
          const matWood = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for ßspecular light
              shininess: 50,      // controls size of specular highlights
              map: woodFloorTexture
          } );
          const matCeiling = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for specular light
              shininess: 30,      // controls size of specular highlights
              map: ceilingTexture
          } );
          const matBrick = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for specular light
              shininess: 20,      // controls size of specular highlights
              map: brickTexture
          } );

          // Setting up meshes
          // Floor Mesh
          floorMesh = new THREE.Mesh( floor, matWood );
          floorMesh.rotation.x = -Math.PI/2;   // Rotate floor to be horizontal
          
          // Ceiling Mesh
          ceilingMesh = new THREE.Mesh( floor, matCeiling);
          ceilingMesh.rotation.x = Math.PI/2;   // Rotate floor to be horizontal
          ceilingMesh.position.y = 70;   // Rotate floor to be horizontal

          // North Wall Mesh
          northWallMesh = new THREE.Mesh( wall, matBrick);
          northWallMesh.position.z = -60;
          northWallMesh.position.y = 35;

          // South Wall Mesh
          southWallMesh = new THREE.Mesh( wall, matBrick);
          southWallMesh.rotation.y = Math.PI;
          southWallMesh.position.z = 60;
          southWallMesh.position.y = 35;

          // East Wall Mesh
          eastWallMesh = new THREE.Mesh( wall, matBrick);
          eastWallMesh.rotation.y = -Math.PI/2;
          eastWallMesh.position.x = 60;
          eastWallMesh.position.y = 35;

          // West Wall Mesh
          westWallMesh = new THREE.Mesh( wall, matBrick);
          westWallMesh.rotation.y = Math.PI/2;
          westWallMesh.position.x = -60;
          westWallMesh.position.y = 35;

          // Adding meshes to parent
          parent.add(floorMesh);
          parent.add(ceilingMesh);
          parent.add(northWallMesh);
          parent.add(southWallMesh);
          parent.add(eastWallMesh);
          parent.add(westWallMesh);
      }
      
      function createSnowman(parent) {
          // The holder for our snowman object
          snowman = new THREE.Object3D();

          // Set the material property for the ball
          const snowManMat = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x200000,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x828282,  // reflectivity for specular light
              shininess: 100       // controls size of specular highlights
          } );

          // Create the base of the snowman
          const baseGeometry = new THREE.SphereGeometry(3, 20, 20);
          const midGeometry = new THREE.SphereGeometry(2, 20, 20);
          const headGeometry = new THREE.SphereGeometry(1, 20, 20);

          const baseMesh = new THREE.Mesh(baseGeometry, snowManMat);
          const midMesh = new THREE.Mesh(midGeometry, snowManMat);
          const headMesh = new THREE.Mesh(headGeometry, snowManMat);

          snowman.add(baseMesh);
          baseMesh.position.y = 3;
          snowman.add(midMesh);
          midMesh.position.y = 8;
          snowman.add(headMesh);
          headMesh.position.y = 11;

          parent.add(snowman);
      }
      
      function createBall(parent) {
          // Create the Sphere Geometry
          const geometry = new THREE.SphereGeometry(50, 20, 20);

          // Set the material property for the ball
          const mat = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x200000,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x828282,  // reflectivity for specular light
              shininess: 100       // controls size of specular highlights
          } );
          
          // Create the mesh and add it to the scene
          //   We are making the ballMesh global so it can be altered by animation
          ballMesh = new THREE.Mesh( geometry, mat );
          parent.add(ballMesh);

      }

      // On a window resize, recompute the camera's aspect ratio and then update the project matrix based on that.
      function onWindowResize() {
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();

	  renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
	  requestAnimationFrame(animate);  // Request another call to animation frame (as soon as possible)

          // How much time has elapsed since the last animation frame?  (Used for steadier speed)
          const currentTime = performance.now();
          const delta = (currentTime - previousAnimationTime)/1000.0;   // Elapsed time in seconds
          previousAnimationTime = currentTime;

          // Adjust movement (assuming we have locked the mouse pointer to the document)
          if (controls.isLocked) adjustMovement(delta);
                    
          // Rotate the mesh object in the x and y and z directions a bit.
	  snowman.rotation.z += dz;
          if (snowman.rotation.z < -0.5) {
              snowman.rotation.z = -0.5;
              dz = -dz;
          } else if (snowman.rotation.z > 0.5) {
              snowman.rotation.z = 0.5;
              dz = -dz;
          }

          // And now render the scene using the camera
          //    The renderer does all the set up and calling
	  renderer.render(scene, camera);
      }

      // Adjust the camera's position based on keys pressed
      function adjustMovement(delta) {
          // Compute the direction to move based on the WASD keys pressed
          moveDirection.x = Number(moveRight) - Number(moveLeft);  // Since the keyboard allows pushing both at same time (they can cancel each other)
          moveDirection.z = Number(moveForward) - Number(moveBackward);
          moveDirection.normalize();   // Make sure that the direction is of unit length (so diagonal is not faster)

          // Check if the camera is touching the scene boundaries
          if (camera.position.x >= BOUND_MAX) {
              camera.position.x = BOUND_MAX;
          }
          if (camera.position.x <= BOUND_MIN) {
              camera.position.x = BOUND_MIN;
          }
          if (camera.position.z >= BOUND_MAX) {
              camera.position.z = BOUND_MAX;
          }
          if (camera.position.z <= BOUND_MIN) {
              camera.position.z = BOUND_MIN;
          }

          controls.moveRight(moveDirection.x*moveSpeed*delta);
          controls.moveForward(moveDirection.z*moveSpeed*delta);
      }
    </script>

  </body>
</html>
